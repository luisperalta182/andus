'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _style = require('./css/style.css');

var _style2 = _interopRequireDefault(_style);

var _HorizontalRail = require('./HorizontalRail');

var _HorizontalRail2 = _interopRequireDefault(_HorizontalRail);

var _VerticalRail = require('./VerticalRail');

var _VerticalRail2 = _interopRequireDefault(_VerticalRail);

var _helpers = require('../helpers');

var _helpers2 = _interopRequireDefault(_helpers);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Container = function (_React$Component) {
    (0, _inherits3.default)(Container, _React$Component);

    function Container(props) {
        (0, _classCallCheck3.default)(this, Container);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Container.__proto__ || (0, _getPrototypeOf2.default)(Container)).call(this, props));

        _this.element = null;
        _this.state = {
            horizontalBarDragging: false,
            verticalBarDragging: false,
            scrollBarXActive: false,
            scrollBarYActive: false,
            horizontalRailWidth: 0,
            horizontalRailLeft: 0,
            horizontalRailTop: 0,
            horizontalRailBottom: 0,
            horizontalBarWidth: 0,
            horizontalBarLeft: 0,
            verticalRailHeight: 0,
            verticalRailTop: 0,
            verticalRailLeft: 0,
            verticalRailRight: 0,
            verticalBarHeight: 0,
            verticalBarTop: 0,
            isVerticalBarUsingRight: false,
            isHorizontalBarUsingBottom: false
        };

        _this.metaProps = {
            scrollBarXActive: false,
            scrollBarYActive: false,
            containerWidth: null,
            containerHeight: null,
            contentWidth: null,
            contentHeight: null,
            isRtl: false,
            isNegativeScroll: false,
            negativeScrollAdjustment: 0,
            ownerDocument: document,

            horizontalBarWidth: null,
            horizontalBarLeft: null,
            horizontalBarTop: null,
            horizontalBarBottom: null,
            isHorizontalBarUsingBottom: false,
            horizontalRailWidth: null,
            horizontalRailRatio: null,
            horizontalRailBorderWidth: null,
            horizontalRailMarginWidth: null,

            verticalBarHeight: null,
            verticalBarTop: null,
            verticalBarRight: null,
            isVerticalBarUsingRight: false,
            verticalBarLeft: null,
            verticalBarOuterWidth: null,
            verticalRailHeight: null,
            verticalRailRatio: null,
            verticalRailBorderWidth: null,
            verticalRailMarginHeight: null,

            lastLeft: null,
            lastTop: null
        };

        _this.selectionParams = {
            isContentSelected: false
        };

        _this.scrollParams = {
            scrollDifference: {
                left: 0,
                top: 0
            },
            scrollingLoop: null
        };

        _this.globals = {
            shouldPrevent: false
        };

        _this.updatePostMountMetaProps = _this.updatePostMountMetaProps.bind(_this);
        _this.updateState = _this.updateState.bind(_this);
        _this.getScrollThumbSize = _this.getScrollThumbSize.bind(_this);
        _this.updateContainerScroll = _this.updateContainerScroll.bind(_this);
        _this.updateGeometry = _this.updateGeometry.bind(_this);
        _this.handleOnNativeScroll = _this.handleOnNativeScroll.bind(_this);
        _this.setContainerState = _this.setContainerState.bind(_this);

        // Scroll when text or other content in container is selected by
        // mouse or keyboard
        _this.handleSelectionChange = _this.handleSelectionChange.bind(_this);
        _this.handleSelectionMouseUp = _this.handleSelectionMouseUp.bind(_this);
        _this.handleSelectionKeyUp = _this.handleSelectionKeyUp.bind(_this);
        _this.handleWindowMouseMove = _this.handleWindowMouseMove.bind(_this);
        _this.startScrolling = _this.startScrolling.bind(_this);
        _this.stopScrolling = _this.stopScrolling.bind(_this);

        // Handle scroll with mouse wheel in the container
        _this.handleMouseWheelOnContainer = _this.handleMouseWheelOnContainer.bind(_this);
        _this.shouldPreventDefaultOnWheel = _this.shouldPreventDefaultOnWheel.bind(_this);
        return _this;
    }

    /**
     * Get scrollbar thumb size
     *
     * @param  {Integer|Float} thumbSize
     * @return {Integer|Float} thumbSize
     */


    (0, _createClass3.default)(Container, [{
        key: 'getScrollThumbSize',
        value: function getScrollThumbSize(thumbSize) {
            var props = this.props;

            if (props.minScrollbarLength) {
                thumbSize = Math.max(thumbSize, props.minScrollbarLength);
            }
            if (props.maxScrollbarLength) {
                thumbSize = Math.min(thumbSize, props.maxScrollbarLength);
            }
            return thumbSize;
        }

        /**
         * Bind events for mouse wheel and content selection scroll handling
         *
         * @return {*}
         */

    }, {
        key: 'bindPostMountEvents',
        value: function bindPostMountEvents() {

            if (typeof window.onwheel !== "undefined") {
                window.addEventListener('wheel', this.handleMouseWheelOnContainer);
            } else if (typeof window.onmousewheel !== "undefined") {
                window.addEventListener('mousewheel', this.handleMouseWheelOnContainer);
            }

            this.metaProps.ownerDocument.addEventListener('selectionchange', this.handleSelectionChange);
            window.addEventListener('mouseup', this.handleSelectionMouseUp);
            window.addEventListener('mousemove', this.handleWindowMouseMove);
            window.addEventListener('keyup', this.handleSelectionKeyUp);
        }

        /**
         * Update post mount meta properties of the component
         *
         * @return {*}
         */

    }, {
        key: 'updatePostMountMetaProps',
        value: function updatePostMountMetaProps() {
            var mainElement = _reactDom2.default.findDOMNode(this);
            var horizontalRail = _reactDom2.default.findDOMNode(this.refs.xrail);
            var horizontalBar = _reactDom2.default.findDOMNode(this.refs.xbar);
            var verticalRail = _reactDom2.default.findDOMNode(this.refs.yrail);
            var verticalBar = _reactDom2.default.findDOMNode(this.refs.ybar);
            var mp = this.metaProps;

            this.element = mainElement;

            mp.isRtl = _helpers2.default.css(mainElement, 'direction') === "rtl";
            mp.horizontalBarBottom = _helpers2.default.toInt(_helpers2.default.css(horizontalRail, 'bottom'));
            mp.isHorizontalBarUsingBottom = mp.horizontalBarBottom === mp.horizontalBarBottom; // !isNaN
            mp.horizontalBarTop = mp.isHorizontalBarUsingBottom ? null : _helpers2.default.toInt(_helpers2.default.css(horizontalRail, 'top'));
            mp.horizontalRailBorderWidth = _helpers2.default.toInt(_helpers2.default.css(horizontalRail, 'borderLeftWidth')) + _helpers2.default.toInt(_helpers2.default.css(horizontalRail, 'borderRightWidth'));
            mp.horizontalRailMarginWidth = _helpers2.default.toInt(_helpers2.default.css(horizontalRail, 'marginLeft')) + _helpers2.default.toInt(_helpers2.default.css(horizontalRail, 'marginRight'));

            mp.verticalBarRight = _helpers2.default.toInt(_helpers2.default.css(verticalRail, 'right'));
            mp.isVerticalBarUsingRight = mp.verticalBarRight === mp.verticalBarRight; // !isNaN
            mp.verticalBarLeft = mp.isVerticalBarUsingRight ? null : _helpers2.default.toInt(_helpers2.default.css(verticalRail, 'left'));
            mp.verticalBarOuterWidth = mp.isRtl ? _helpers2.default.outerWidth(verticalBar) : null;
            mp.verticalRailBorderWidth = _helpers2.default.toInt(_helpers2.default.css(verticalRail, 'borderTopWidth')) + _helpers2.default.toInt(_helpers2.default.css(verticalRail, 'borderBottomWidth'));
            mp.verticalRailMarginHeight = _helpers2.default.toInt(_helpers2.default.css(verticalRail, 'marginTop')) + _helpers2.default.toInt(_helpers2.default.css(verticalRail, 'marginBottom'));

            mp.containerWidth = mainElement.clientWidth;
            mp.containerHeight = mainElement.clientHeight;
            mp.contentWidth = mainElement.scrollWidth;
            mp.contentHeight = mainElement.scrollHeight;

            var isNegativeScroll = function () {
                var originalScrollLeft = mainElement.scrollLeft;
                var result = null;
                mainElement.scrollLeft = -1;
                result = mainElement.scrollLeft < 0;
                mainElement.scrollLeft = originalScrollLeft;
                return result;
            }();
            mp.negativeScrollAdjustment = isNegativeScroll ? mainElement.scrollWidth - mainElement.clientWidth : 0;
        }

        /**
         * Component Did Mount
         *
         * @return {*}
         */

    }, {
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.updatePostMountMetaProps();
            this.bindPostMountEvents();
            this.updateGeometry();
            setTimeout(function () {
                this.updateState();
            }.bind(this), 1000);
        }

        /**
         * Handle Native Scrolling
         *
         * @return {*}
         */

    }, {
        key: 'handleOnNativeScroll',
        value: function handleOnNativeScroll() {
            this.updateGeometry();
            this.updateState();
        }

        /**
         * Set component state from child comps
         *
         * @param {Object} state
         * @return {*}
         */

    }, {
        key: 'setContainerState',
        value: function setContainerState(state) {
            this.setState(state);
        }

        /**
         * Update scroll rails and bar's geometry
         *
         * @return {*}
         */

    }, {
        key: 'updateGeometry',
        value: function updateGeometry() {
            var element = this.element;
            var props = this.props;
            var mp = this.metaProps;

            if (!props.suppressScrollX && mp.containerWidth + props.scrollXMarginOffset < mp.contentWidth) {
                mp.scrollBarXActive = true;
                mp.horizontalRailWidth = mp.containerWidth - mp.horizontalRailMarginWidth;
                mp.horizontalRailRatio = mp.containerWidth / mp.horizontalRailWidth;
                mp.horizontalBarWidth = this.getScrollThumbSize(_helpers2.default.toInt(mp.horizontalRailWidth * mp.containerWidth / mp.contentWidth));
                mp.horizontalBarLeft = _helpers2.default.toInt((mp.negativeScrollAdjustment + element.scrollLeft) * (mp.horizontalRailWidth - mp.horizontalBarWidth) / (mp.contentWidth - mp.containerWidth));
            }

            if (!props.suppressScrollY && mp.containerHeight + props.scrollYMarginOffset < mp.contentHeight) {
                mp.scrollBarYActive = true;
                mp.verticalRailHeight = mp.containerHeight - mp.verticalRailMarginHeight;
                mp.verticalRailRatio = mp.containerHeight / mp.verticalRailHeight;
                mp.verticalBarHeight = this.getScrollThumbSize(_helpers2.default.toInt(mp.verticalRailHeight * mp.containerHeight / mp.contentHeight));
                mp.verticalBarTop = _helpers2.default.toInt(element.scrollTop * (mp.verticalRailHeight - mp.verticalBarHeight) / (mp.contentHeight - mp.containerHeight));
            }

            if (mp.horizontalBarLeft >= mp.horizontalRailWidth - mp.horizontalBarWidth) {
                mp.horizontalBarLeft = mp.horizontalRailWidth - mp.horizontalBarWidth;
            }

            if (mp.verticalBarTop >= mp.verticalRailHeight - mp.verticalBarHeight) {
                mp.verticalBarTop = mp.verticalRailHeight - mp.verticalBarHeight;
            }
        }

        /**
         * Update the actual element scrollbar and emit events
         *
         * @param  {String} axis  left|top
         * @param  {Integer} value
         * @return {*}
         */

    }, {
        key: 'updateContainerScroll',
        value: function updateContainerScroll(axis, value) {
            var element = this.element;
            var metaProps = this.metaProps;

            if (typeof axis === 'undefined') {
                throw 'You must provide an axis to the update-scroll function';
            }

            if (typeof value === 'undefined') {
                throw 'You must provide a value to the update-scroll function';
            }

            if (axis === 'top' && value <= 0) {
                element.scrollTop = value = 0;
                this.props.onScrollYReachStart.call(this);
            }

            if (axis === 'left' && value <= 0) {
                element.scrollLeft = value = 0;
                this.props.onScrollXReachStart.call(this);
            }

            if (axis === 'top' && value >= this.metaProps.contentHeight - this.metaProps.containerHeight) {
                value = this.metaProps.contentHeight - this.metaProps.containerHeight;
                if (value - element.scrollTop <= 1) {
                    value = element.scrollTop;
                } else {
                    element.scrollTop = value;
                }
                this.props.onScrollYReachEnd.call(this);
            }

            if (axis === 'left' && value >= this.metaProps.contentWidth - this.metaProps.containerWidth) {
                value = this.metaProps.contentWidth - this.metaProps.containerWidth;
                if (value - element.scrollLeft <= 1) {
                    value = element.scrollLeft;
                } else {
                    element.scrollLeft = value;
                }
                this.props.onScrollXReachEnd.call(this);
            }

            if (!metaProps.lastTop) {
                metaProps.lastTop = element.scrollTop;
            }

            if (!metaProps.lastLeft) {
                metaProps.lastLeft = element.scrollLeft;
            }

            if (axis === 'top' && value < metaProps.lastTop) {
                this.props.onScrollUp.call(this);
            }

            if (axis === 'top' && value > metaProps.lastTop) {
                this.props.onScrollDown.call(this);
            }

            if (axis === 'left' && value < metaProps.lastLeft) {
                this.props.onScrollLeft.call(this);
            }

            if (axis === 'left' && value > metaProps.lastLeft) {
                this.props.onScrollRight.call(this);
            }

            if (axis === 'top') {
                element.scrollTop = metaProps.lastTop = value;
                this.props.onScrollY.call(this);
            }

            if (axis === 'left') {
                element.scrollLeft = metaProps.lastLeft = value;
                this.props.onScrollX.call(this);
            }
        }

        /**
         * Update the actual state to re-render the entire component tree
         *
         * @return {*}
         */

    }, {
        key: 'updateState',
        value: function updateState() {
            var mp = this.metaProps;
            var element = _reactDom2.default.findDOMNode(this);
            var ns = {};

            ns['horizontalRailWidth'] = mp.horizontalRailWidth;

            if (mp.isRtl) {
                ns['horizontalRailLeft'] = mp.negativeScrollAdjustment + element.scrollLeft + mp.containerWidth - mp.contentWidth;
            } else {
                ns['horizontalRailLeft'] = element.scrollLeft;
            }
            if (mp.isHorizontalBarUsingBottom) {
                ns['horizontalRailBottom'] = mp.horizontalBarBottom - element.scrollTop;
            } else {
                ns['horizontalRailTop'] = mp.horizontalBarTop + element.scrollTop;
            }

            ns['verticalRailHeight'] = mp.verticalRailHeight;
            ns['verticalRailTop'] = element.scrollTop;

            if (mp.isVerticalBarUsingRight) {
                if (mp.isRtl) {
                    ns['verticalRailRight'] = mp.contentWidth - (mp.negativeScrollAdjustment + element.scrollLeft) - mp.verticalBarRight - i.verticalBarOuterWidth;
                } else {
                    ns['verticalRailRight'] = mp.verticalBarRight - element.scrollLeft;
                }
            } else {
                if (mp.isRtl) {
                    ns['verticalRailLeft'] = mp.negativeScrollAdjustment + element.scrollLeft + mp.containerWidth * 2 - mp.contentWidth - mp.verticalBarLeft - mp.verticalBarOuterWidth;
                } else {
                    ns['verticalRailLeft'] = mp.verticalBarLeft + element.scrollLeft;
                }
            }

            ns['horizontalBarLeft'] = mp.horizontalBarLeft;
            ns['horizontalBarWidth'] = mp.horizontalBarWidth - mp.horizontalRailBorderWidth;
            ns['verticalBarTop'] = mp.verticalBarTop;
            ns['verticalBarHeight'] = mp.verticalBarHeight - mp.verticalRailBorderWidth;

            this.setState((0, _extends3.default)({
                scrollBarXActive: mp.scrollBarXActive,
                scrollBarYActive: mp.scrollBarYActive,
                isVerticalBarUsingRight: mp.isVerticalBarUsingRight,
                isHorizontalBarUsingBottom: mp.isHorizontalBarUsingBottom
            }, ns));
        }

        /**
         * Mouse and Keyboard Event Handling Functions
         */

        /**
         * Handle selection change from mouse or keyboard
         *
         * @return {*}
         */

    }, {
        key: 'handleSelectionChange',
        value: function handleSelectionChange() {
            var isContentSelected = this.selectionParams.isContentSelected;

            if (this.element.contains(_helpers2.default.getRangeNode())) {
                isContentSelected = true;
            } else {
                isContentSelected = false;
                this.stopScrolling();
            }
        }

        /**
         * Handle key up when content is already selected
         *
         * @return {*}
         */

    }, {
        key: 'handleSelectionKeyUp',
        value: function handleSelectionKeyUp() {
            var isContentSelected = this.selectionParams.isContentSelected;

            if (isContentSelected) {
                isContentSelected = false;
                this.stopScrolling();
            }
        }

        /**
         * Handle mouse up when content is already selected
         *
         * @return {*}
         */

    }, {
        key: 'handleSelectionMouseUp',
        value: function handleSelectionMouseUp() {
            var isContentSelected = this.selectionParams.isContentSelected;

            if (isContentSelected) {
                isContentSelected = false;
                this.stopScrolling();
            }
        }

        /**
         * Handle mouse move on window when text or any content is selected
         * in the given container
         *
         * @param  {Object} e
         * @return {*}
         */

    }, {
        key: 'handleWindowMouseMove',
        value: function handleWindowMouseMove(e) {
            var element = this.element;
            var isContentSelected = this.selectionParams.isContentSelected;

            var scrollDifference = this.scrollParams.scrollDifference,
                mousePosition = void 0,
                containerGeometry = void 0;

            if (isContentSelected) {
                mousePosition = {
                    x: e.pageX,
                    y: e.pageY
                };
                containerGeometry = {
                    left: element.offsetLeft,
                    right: element.offsetLeft + element.offsetWidth,
                    top: element.offsetTop,
                    bottom: element.offsetTop + element.offsetHeight
                };

                if (mousePosition.x < containerGeometry.left + 3) {
                    scrollDifference.left = -5;
                } else if (mousePosition.x > containerGeometry.right - 3) {
                    scrollDifference.left = 5;
                } else {
                    scrollDifference.left = 0;
                }

                if (mousePosition.y < containerGeometry.top + 3) {
                    if (containerGeometry.top + 3 - mousePosition.y < 5) {
                        scrollDifference.top = -5;
                    } else {
                        scrollDifference.top = -20;
                    }
                } else if (mousePosition.x > containerGeometry.right - 3) {
                    if (mousePosition.y - containerGeometry.bottom + 3 < 5) {
                        scrollDifference.top = 5;
                    } else {
                        scrollDifference.top = 20;
                    }
                } else {
                    scrollDifference.left = 0;
                }

                if (scrollDifference.top === 0 && scrollDifference.left === 0) {
                    this.stopScrolling();
                } else {
                    this.startScrolling();
                }
            }
        }

        /**
         * Start scrolling and update the actual scroll and geometry
         * according to the scrollDifference
         *
         * @return {*}
         */

    }, {
        key: 'startScrolling',
        value: function startScrolling() {
            var element = this.element;
            var scrollingLoop = this.scrollParams.scrollingLoop,
                scrollDifference = this.scrollParams.scrollDifference,
                top = void 0,
                left = void 0;

            if (!scrollingLoop) {
                scrollingLoop = setInterval(function () {
                    if (!element) {
                        clearInterval(scrollingLoop);
                        return;
                    }
                    top = element.scrollTop + scrollDifference.top;
                    left = element.scrollLeft + scrollDifference.left;

                    this.updateContainerScroll('top', top);
                    this.updateContainerScroll('left', left);
                    this.updateGeometry();
                }.bind(this), 50);
            }
        }

        /**
         * Stop scrolling and reset the scrollingLoop interval
         *
         * @return {*}
         */

    }, {
        key: 'stopScrolling',
        value: function stopScrolling() {
            var scrollingLoop = this.scrollParams.scrollingLoop;

            if (scrollingLoop) {
                clearInterval(scrollingLoop);
                scrollingLoop = null;
            }
        }

        /**
         * Should prevent default scrollbar when scrolling with mouse
         * wheel
         *
         * @param  {Integer|Float} deltaX
         * @param  {Integer|Float} deltaY
         * @return {Boolean}
         */

    }, {
        key: 'shouldPreventDefaultOnWheel',
        value: function shouldPreventDefaultOnWheel(deltaX, deltaY) {
            var element = this.element;
            var props = this.props;
            var metaProps = this.metaProps;
            var scrollTop = element.scrollTop;
            var scrollLeft = element.scrollLeft;

            if (deltaX === 0) {
                if (metaProps.scrollBarYActive) {
                    return false;
                }
                if (scrollTop === 0 && deltaY > 0 || scrollTop >= metaProps.contentHeight - metaProps.containerHeight && deltaY < 0) {
                    return !props.wheelPropagation;
                }
            }

            if (deltaY === 0) {
                if (metaProps.scrollbarXActive) {
                    return false;
                }
                if (scrollLeft === 0 && deltaX < 0 || scrollLeft >= metaProps.contentWidth - metaProps.containerWidth && deltaX > 0) {
                    return !props.wheelPropagation;
                }
            }
            return true;
        }

        /**
         * Handle mouse wheel movement on container
         *
         * @param  {Object} e
         * @return {*}
         */

    }, {
        key: 'handleMouseWheelOnContainer',
        value: function handleMouseWheelOnContainer(e) {
            var delta = _helpers2.default.getDeltaFromEvent(e);
            var deltaX = delta[0];
            var deltaY = delta[1];
            var element = this.element;
            var globals = this.globals,
                newTop = void 0,
                newLeft = void 0;

            if (_helpers2.default.shouldScrollUsedByChild(element, deltaX, deltaY)) {
                return;
            }

            if (!this.props.useBothWheelAxes) {
                newTop = element.scrollTop - deltaY * this.props.wheelSpeed;
                newLeft = element.scrollLeft + deltaX * this.props.wheelSpeed;
                this.updateContainerScroll('top', newTop);
                this.updateContainerScroll('left', newLeft);
            } else if (this.state.scrollbarYActive && !this.state.scrollbarXActive) {
                if (deltaY) {
                    this.updateContainerScroll('top', element.scrollTop - deltaY * this.props.wheelSpeed);
                } else {
                    this.updateContainerScroll('top', element.scrollTop + deltaX * this.props.wheelSpeed);
                }
                globals.shouldPrevent = true;
            } else if (this.state.scrollbarXActive && !this.state.scrollbarYActive) {
                if (deltaX) {
                    this.updateContainerScroll('left', element.scrollLeft + deltaX * this.props.wheelSpeed);
                } else {
                    this.updateContainerScroll('left', element.scrollLeft - deltaY * this.props.wheelSpeed);
                }
                globals.shouldPrevent = true;
            }

            this.updateGeometry();
            this.updateState();

            globals.shouldPrevent = globals.shouldPrevent || this.shouldPreventDefaultOnWheel(deltaX, deltaY);
            if (globals.shouldPrevent) {
                e.stopPropagation();
                e.preventDefault();
            }
        }

        /**
         * Render the entire component
         *
         * @return {JSX}
         */

    }, {
        key: 'render',
        value: function render() {
            var containerStyle = {
                width: this.props.width + 'px',
                height: this.props.height + 'px',
                overflow: 'hidden',
                position: 'relative'
            };

            var containerClasses = ['ps-container', 'ps-theme-' + this.props.theme];

            if (this.state.scrollBarXActive) {
                containerClasses.push('ps-active-x');
            }

            if (this.state.scrollBarYActive) {
                containerClasses.push('ps-active-y');
            }

            if (this.state.horizontalBarDragging || this.state.verticalBarDragging) {
                containerClasses.push('ps-in-scrolling');
            }

            if (this.state.horizontalBarDragging) {
                containerClasses.push('ps-x');
            }

            if (this.state.verticalBarDragging) {
                containerClasses.push('ps-y');
            }

            containerClasses = containerClasses.join(' ');

            return _react2.default.createElement(
                'div',
                {
                    ref: 'main',
                    style: containerStyle,
                    className: containerClasses,
                    onScroll: this.handleOnNativeScroll
                },
                _react2.default.createElement(
                    'div',
                    null,
                    this.props.children
                ),
                _react2.default.createElement(_HorizontalRail2.default, (0, _extends3.default)({
                    ref: 'xrail'
                }, this.state, this.metaProps, {
                    updateContainerScroll: this.updateContainerScroll,
                    updateGeometry: this.updateGeometry,
                    setContainerState: this.setContainerState,
                    updateState: this.updateState
                })),
                _react2.default.createElement(_VerticalRail2.default, (0, _extends3.default)({
                    ref: 'yrail'
                }, this.state, this.metaProps, {
                    updateContainerScroll: this.updateContainerScroll,
                    updateGeometry: this.updateGeometry,
                    setContainerState: this.setContainerState,
                    updateState: this.updateState
                }))
            );
        }
    }]);
    return Container;
}(_react2.default.Component);

Container.defaultProps = {
    containerClass: '',
    width: 200,
    height: 200,
    wheelSpeed: 1,
    wheelPropagation: false,
    swipePropagation: false,
    minScrollbarLength: null,
    maxScrollbarLength: null,
    useBothWheelAxes: false,
    suppressScrollX: false,
    suppressScrollY: false,
    scrollXMarginOffset: 0,
    scrollYMarginOffset: 0,
    theme: 'default',
    onScrollX: function onScrollX() {},
    onScrollY: function onScrollY() {},
    onScrollUp: function onScrollUp() {},
    onScrollDown: function onScrollDown() {},
    onScrollLeft: function onScrollLeft() {},
    onScrollRight: function onScrollRight() {},
    onScrollXReachStart: function onScrollXReachStart() {},
    onScrollXReachEnd: function onScrollXReachEnd() {},
    onScrollYReachStart: function onScrollYReachStart() {},
    onScrollYReachEnd: function onScrollYReachEnd() {}
};

exports.default = Container;