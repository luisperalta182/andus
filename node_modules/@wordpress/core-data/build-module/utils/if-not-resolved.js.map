{"version":3,"sources":["@wordpress/core-data/src/utils/if-not-resolved.js"],"names":["controls","STORE_NAME","ifNotResolved","resolver","selectorName","resolveIfNotResolved","args","hasStartedResolution","select"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,QAAT,QAAyB,iBAAzB;AAEA;AACA;AACA;;AACA,SAASC,UAAT,QAA2B,SAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,aAAa,GAAG,CAAEC,QAAF,EAAYC,YAAZ;AACrB;AACD;AACA;AACC,UAAUC,oBAAV,CAAgC,GAAGC,IAAnC,EAA0C;AACzC,QAAMC,oBAAoB,GAAG,MAAMP,QAAQ,CAACQ,MAAT,CAClCP,UADkC,EAElC,sBAFkC,EAGlCG,YAHkC,EAIlCE,IAJkC,CAAnC;;AAOA,MAAK,CAAEC,oBAAP,EAA8B;AAC7B,WAAOJ,QAAQ,CAAE,GAAGG,IAAL,CAAf;AACA;AACD,CAfF;;AAiBA,eAAeJ,aAAf","sourcesContent":["/**\n * WordPress dependencies\n */\nimport { controls } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport { STORE_NAME } from '../name';\n\n/**\n * Higher-order function which invokes the given resolver only if it has not\n * already been resolved with the arguments passed to the enhanced function.\n *\n * This only considers resolution state, and notably does not support resolver\n * custom `isFulfilled` behavior.\n *\n * @param {Function} resolver     Original resolver.\n * @param {string}   selectorName Selector name associated with resolver.\n *\n * @return {Function} Enhanced resolver.\n */\nconst ifNotResolved = ( resolver, selectorName ) =>\n\t/**\n\t * @param {...any} args Original resolver arguments.\n\t */\n\tfunction* resolveIfNotResolved( ...args ) {\n\t\tconst hasStartedResolution = yield controls.select(\n\t\t\tSTORE_NAME,\n\t\t\t'hasStartedResolution',\n\t\t\tselectorName,\n\t\t\targs\n\t\t);\n\n\t\tif ( ! hasStartedResolution ) {\n\t\t\tyield* resolver( ...args );\n\t\t}\n\t};\n\nexport default ifNotResolved;\n"]}